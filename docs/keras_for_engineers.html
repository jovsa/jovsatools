---

title: Title


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/keras_for_engineers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/keras_for_engineers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Everything you need to know to use Keras &amp; TF 2.0 to build real-world machine learning solutions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Setup">Setup<a class="anchor-link" href="#Setup"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Introduction">Introduction<a class="anchor-link" href="#Introduction"> </a></h2><p>Are you a machine learning looking to use Keras
to ship deep-learning powered features in real products? This guide will serve
as your first introduction to core Keras API concepts.</p>
<p>In this guide, you will learn about:</p>
<ul>
<li>How to prepare you data before training a model (by turning it into either NumPy arrays or <code>tf.data.Dataset</code> objects).</li>
<li>How to do data preprocessing, for instance feature normalization or vocabulary indexing.</li>
<li>How to build a model that turns your data into useful predictions,
using the Keras Functional API.</li>
<li>How to train your model with the built-in Keras <code>fit()</code> method, while being.
mindful of checkpointing, metrics monitoring, and fault tolerance.</li>
<li>How to evaluate your model on a test data and how to use it for inference on new data.</li>
<li>How to customize what <code>fit()</code> does, for instance to build a GAN.</li>
<li>How to speed up training by leveraging multiple GPUs.</li>
<li>How to refine your model through hyperparameter tuning.</li>
</ul>
<p>At the end of this guide, you will get pointers to end-to-end examples to solidify these concepts:</p>
<ul>
<li>Image classification</li>
<li>Text classification</li>
<li>Credit card fraud detection</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Data-loading-&amp;-preprocessing">Data loading &amp; preprocessing<a class="anchor-link" href="#Data-loading-&amp;-preprocessing"> </a></h2><p>Neural networks don't process raw data, like text files, encoded JPEG image files, or CSV files. They process <strong>vectorized</strong> &amp; <strong>standardized</strong> representations.</p>
<ul>
<li>Text files needs to be read into string tensors, then split into words. Finally, the words need to be indexed &amp; turned into integer tensors.</li>
<li>Images need to be read and decoded into integer tensors, then converted to floating point and normalized to small values (usually between 0 and 1).</li>
<li>CSV data needs to be parsed, with numerical features converted to floating point tensors and categorical features indexed and converted to integer tensors.
Then each feature typically needs to be normalized to zero-mean and unit-variance.</li>
<li>Etc.</li>
</ul>
<p>Let's start with data loading.</p>
<h2 id="Data-loading">Data loading<a class="anchor-link" href="#Data-loading"> </a></h2><p>Keras models accept three types of inputs:</p>
<ul>
<li><strong>NumPy arrays</strong>, just like Scikit-Learn and many other Python-based libraries. This is a good option if your data fits in memory.</li>
<li><strong><a href="https://www.tensorflow.org/guide/data">TensorFlow <code>Dataset</code> objects</a></strong>. This is a high-performance option that is more suitable for datasets that do not fit in memory and that are streamed from disk or from a distributed filesystem.</li>
<li><strong>Python generators</strong> that yield batches of data (such as custom subclasses of
the <code>keras.utils.Sequence</code> class).</li>
</ul>
<p>Before you start training a model, you will need to make your data available as one of these formats. If you have a large dataset and you are training on GPU(s), consider using <code>Dataset</code> objects, since they will take care of performance-critical details, such as:</p>
<ul>
<li>Asynchronously preprocessing your data on CPU while your CPU is busy, and bufferring it into a queue.</li>
<li>Prefetching data on GPU memory so it's immediately available when the GPU has finished processing the previous batch, so you can reach full GPU utilization.</li>
</ul>
<p>Keras features a range of utilities to help you turn raw data on disk into a <code>Dataset</code>:</p>
<ul>
<li><code>tf.keras.preprocessing.image_dataset_from_directory</code> turns image files sorted into class-specific folders into a labeled dataset of image tensors.</li>
<li><code>tf.keras.preprocessing.text_dataset_from_directory</code> does the same for text files.</li>
</ul>
<p>In addition, the TensorFlow <code>tf.data</code> includes other similar utilities, such as
<code>tf.data.experimental.make_csv_dataset</code> to load structured data from CSV files.</p>
<p><strong>Example: obtaining a labeled dataset from image files on disk</strong></p>
<p>Supposed you have image files sorted by class in different folders, like this:</p>

<pre><code>main_directory/
...class_a/
......a_image_1.jpg
......a_image_2.jpg
...class_b/
......b_image_1.jpg
......b_image_2.jpg</code></pre>
<p>Then you can do:</p>
<div class="highlight"><pre><span></span><span class="c1"># Create a dataset.</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">image_dataset_from_directory</span><span class="p">(</span>
  <span class="s1">&#39;path/to/main_directory&#39;</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>

<span class="c1"># For demonstration, iterate over the batches yielded by the dataset.</span>
<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (64, 200, 200, 3)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># float32</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (64,)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># int32</span>
</pre></div>
<p>The label of a sample is the rank of its folder in alphanumeric order. Naturally, this can also be configured explicitly by passing, e.g.
<code>class_names=['class_a', 'class_b']</code>, in which cases label <code>0</code> will be <code>class_a</code> and <code>1</code> will be <code>class_b</code>.</p>
<p><strong>Example: obtaining a labeled dataset from text files on disk</strong></p>
<p>Likewise for text: if you have <code>.txt</code> documents sorted by class in different folders, you can do:</p>
<div class="highlight"><pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">text_dataset_from_directory</span><span class="p">(</span>
  <span class="s1">&#39;path/to/main_directory&#39;</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>

<span class="c1"># For demonstration, iterate over the batches yielded by the dataset.</span>
<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (64,)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># string</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (64,)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># int32</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Data-preprocessing-with-Keras">Data preprocessing with Keras<a class="anchor-link" href="#Data-preprocessing-with-Keras"> </a></h2><p>Once your data is in the form of string/int/float NumpPy arrays, or a <code>Dataset</code> object (or Python generator) that yields batches of string/int/float tensors,
it is time to <strong>preprocess</strong> the data. This can mean:</p>
<ul>
<li>Tokenization of string data, followed by token indexing.</li>
<li>Feature normalization.</li>
<li>Rescaling the data to small values (in general, input values to a neural network should be close to zero -- typically we expect either data with zero-mean and unit-variance, or data in the <code>[0, 1]</code> range.</li>
</ul>
<h3 id="The-ideal-machine-learning-model-is-end-to-end">The ideal machine learning model is end-to-end<a class="anchor-link" href="#The-ideal-machine-learning-model-is-end-to-end"> </a></h3><p>In general, you should seek to do data preprocessing <strong>as part of your model</strong> as much as possible, not via an external data preprocessing pipeline. That's because external data preprocessing makes your models less portable when it's time to use them in production. Consider a model that processes text: it uses a specific tokenization algorithm and a specific vocabulary index. When you want to ship your model to a mobile app or a JavaScript app, you will need to recreate the exact same preprocessing setup in the target language. This can get very tricky: any small discrepancy between the original pipeline and the one you recreate has the potential to completely invalidate your model, or at least severely degrade its performance.</p>
<p>It would be much easier to be able to simply export an end-to-end model that already includes preprocessing. <strong>The ideal model should expect as input something as close as possible to raw data: an image model should expect RGB pixel values in the <code>[0, 255]</code> range, and a text model should accept strings of <code>utf-8</code> characters.</strong> That way, the consumer of the exported model doesn't have
to know about the preprocessing pipeline.</p>
<h3 id="Using-Keras-preprocessing-layers">Using Keras preprocessing layers<a class="anchor-link" href="#Using-Keras-preprocessing-layers"> </a></h3><p>In Keras, you do in-model data preprocessing via <strong>preprocessing layers</strong>. This includes:</p>
<ul>
<li>Vectorizing raw strings of text via the <code>TextVectorization</code> layer</li>
<li>Feature normalization via the <code>Normalization</code> layer</li>
<li>Image rescaling, cropping, or image data augmentation</li>
</ul>
<p>The key advatange of using Keras preprocessing layers is that <strong>they can be included directly into your model</strong>, either during training or after training,
which makes your models portable.</p>
<p>Some preprocessing layers have a state:</p>
<ul>
<li><code>TextVectorization</code> holds an index mapping words or tokens to integer indices</li>
<li><code>Normalization</code> holds the mean and variance of your features</li>
</ul>
<p>The state of a preprocessing layers is obtained by calling <code>layer.adapt(data)</code> on a sample of the training data (or all of it).</p>
<p><strong>Example: turning strings into sequences of integer word indices</strong></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.layers.experimental.preprocessing</span> <span class="kn">import</span> <span class="n">TextVectorization</span>

<span class="c1"># Example training data, of dtype `string`.</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s2">&quot;This is the 1st sample.&quot;</span><span class="p">],</span>
                          <span class="p">[</span><span class="s2">&quot;And here&#39;s the 2nd sample.&quot;</span><span class="p">]])</span>

<span class="c1"># Create a TextVectorization layer instance. It can be configured to either</span>
<span class="c1"># return integer token indices, or a dense token representation (e.g. multi-hot</span>
<span class="c1"># or TF-IDF). The text standardization and text splitting algorithms are fully</span>
<span class="c1"># configurable.</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span><span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

<span class="c1"># Calling `adapt` on an array or dataset makes the layer generate a vocabulary</span>
<span class="c1"># index for the data, which can then be reused when seeing new data.</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>

<span class="c1"># After calling adapt, the layer is able to encode any n-gram it has seen before</span>
<span class="c1"># in the `adapt()` data. Unknown n-grams are encoded via an &quot;out-of-vocabulary&quot;</span>
<span class="c1"># token.</span>
<span class="n">integer_data</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integer_data</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tf.Tensor(
[[4 5 2 9 3]
 [7 6 2 8 3]], shape=(2, 5), dtype=int64)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Example: turning strings into sequences of one-hot encoded bigrams</strong></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.layers.experimental.preprocessing</span> <span class="kn">import</span> <span class="n">TextVectorization</span>

<span class="c1"># Example training data, of dtype `string`.</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s2">&quot;This is the 1st sample.&quot;</span><span class="p">],</span>
                          <span class="p">[</span><span class="s2">&quot;And here&#39;s the 2nd sample.&quot;</span><span class="p">]])</span>

<span class="c1"># Create a TextVectorization layer instance. It can be configured to either</span>
<span class="c1"># return integer token indices, or a dense token representation (e.g. multi-hot</span>
<span class="c1"># or TF-IDF). The text standardization and text splitting algorithms are fully</span>
<span class="c1"># configurable.</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span><span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="n">ngrams</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calling `adapt` on an array or dataset makes the layer generate a vocabulary</span>
<span class="c1"># index for the data, which can then be reused when seeing new data.</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>

<span class="c1"># After calling adapt, the layer is able to encode any n-gram it has seen before</span>
<span class="c1"># in the `adapt()` data. Unknown n-grams are encoded via an &quot;out-of-vocabulary&quot;</span>
<span class="c1"># token.</span>
<span class="n">integer_data</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integer_data</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tf.Tensor(
[[0. 1. 1. 1. 1. 0. 1. 1. 1. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 1. 1. 0. 0. 1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 0. 0.]], shape=(2, 17), dtype=float32)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Example: normalizing features</strong></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.layers.experimental.preprocessing</span> <span class="kn">import</span> <span class="n">Normalization</span>
 
<span class="c1"># Example image data, with values in the [0, 255] range</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

<span class="n">normalizer</span> <span class="o">=</span> <span class="n">Normalization</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">normalizer</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>

<span class="n">normalized_data</span> <span class="o">=</span> <span class="n">normalizer</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;var: </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">normalized_data</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean: </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normalized_data</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>var: 1.0000
mean: -0.0000
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Example: rescaling &amp; center-cropping images</strong></p>
<p>Both the <code>Rescaling</code> layer and the <code>CenterCrop</code> layer are stateless, so it isn't necessary to call <code>adapt()</code> in this case.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.layers.experimental.preprocessing</span> <span class="kn">import</span> <span class="n">CenterCrop</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.layers.experimental.preprocessing</span> <span class="kn">import</span> <span class="n">Rescaling</span>

<span class="c1"># Example image data, with values in the [0, 255] range</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

<span class="n">cropper</span> <span class="o">=</span> <span class="n">CenterCrop</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">Rescaling</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>

<span class="n">output_data</span> <span class="o">=</span> <span class="n">scaler</span><span class="p">(</span><span class="n">cropper</span><span class="p">(</span><span class="n">training_data</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape:&#39;</span><span class="p">,</span> <span class="n">output_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;min:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">output_data</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">output_data</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>shape: (64, 150, 150, 3)
min: 0.0
max: 1.0
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Building-models-with-the-Keras-Functional-API">Building models with the Keras Functional API<a class="anchor-link" href="#Building-models-with-the-Keras-Functional-API"> </a></h2><p>A "layer" is a simple input-output transformation (such as the scaling &amp; center-cropping transformations above). For instance, here's a linear projection layer that maps its inputs to a 16-dimensional feature space:</p>
<div class="highlight"><pre><span></span><span class="n">dense</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
<p>A "model" is a directed acyclic graph of layers. You can think of a model as a
"bigger layer" that encompasses multiple sublayers and that can be trained via exposure to data.</p>
<p>The most common and most powerful way to build Keras models is the Functional API. To build models with the Functional API, you start by specifying the shape (and optionally the dtype) of your inputs. If any dimension of your input can vary, you can specify it as <code>None</code>. For instance, an input for 200x200 RBG image would have shape <code>(200, 200, 3)</code>, but an input for RGB images of any size would have shape <code>(None, None, 3)</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After defining your input(s), you chain layer transformations on top of your inputs, until your final output:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">layers</span>

<span class="c1"># Center-crop images to 150x150</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">CenterCrop</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">150</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="c1"># Rescale images to [0, 1]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Rescaling</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Apply some convolution and pooling layers</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Apply global average pooling to get flat feature vectors</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">GlobalAveragePooling2D</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Add a dense classifier on top</span>
<span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once you have defined the directed acylic graph of layers that turns your input(s) into your outputs, instantiate a <code>Model</code> object:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This model behaves basically like a bigger layer. You call it on batches of data, like this:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">processed_data</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">processed_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(64, 10)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can print a summary of how your data gets transformed at each stage of the model. This is useful for debugging.</p>
<p>Note that the output shape displayed for each layers includes the <strong>batch size</strong>. Here the batch size is None, which indicates our model can process batchs of any size.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Model: &#34;functional_1&#34;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_1 (InputLayer)         [(None, None, None, 3)]   0         
_________________________________________________________________
center_crop_1 (CenterCrop)   (None, 150, 150, 3)       0         
_________________________________________________________________
rescaling_1 (Rescaling)      (None, 150, 150, 3)       0         
_________________________________________________________________
conv2d (Conv2D)              (None, 148, 148, 32)      896       
_________________________________________________________________
max_pooling2d (MaxPooling2D) (None, 49, 49, 32)        0         
_________________________________________________________________
conv2d_1 (Conv2D)            (None, 47, 47, 32)        9248      
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 15, 15, 32)        0         
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 13, 13, 32)        9248      
_________________________________________________________________
global_average_pooling2d (Gl (None, 32)                0         
_________________________________________________________________
dense (Dense)                (None, 10)                330       
=================================================================
Total params: 19,722
Trainable params: 19,722
Non-trainable params: 0
_________________________________________________________________
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Functional API also makes it easy to build models that have multiple inputs (for instance, an image <em>and</em> its metadata) or multiple outputs (for instance, predicting the class of the image <em>and</em> the likelihood that a user will click on it). For a deeper dive into what you can do, see our
<a href="/guides/functional_api/">guide to the Functional API</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Training-models-with-fit()">Training models with <code>fit()</code><a class="anchor-link" href="#Training-models-with-fit()"> </a></h2><p>At this point, you know:</p>
<ul>
<li>How to prepare your data (e.g. as a NumPy array or a <code>tf.data.Dataset</code> object)</li>
<li>How to build a model that will process your data</li>
</ul>
<p>The next step is to train your model on your data. The <code>Model</code> class features a built-in training loop, the <code>fit()</code> method. It accepts <code>Dataset</code> objects, Python generators that yield batches of data, or NumPy arrays.</p>
<p>Before you can call <code>fit()</code>, you need to specify an optimizer and a loss function (we asssume you are already familiar with these concepts). This is the <code>compile()</code> step:</p>
<div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">RMSprop</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">),</span>
              <span class="n">loss</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">CategoricalCrossentropy</span><span class="p">())</span>
</pre></div>
<p>Loss and optimizer can be specified via their string identifiers (in this case
their default constructor argument values are used):</p>
<div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">)</span>
</pre></div>
<p>Once your model is compiled, you can start "fitting" the model to the data.
Here's what fitting a model looks like with NumPy data:</p>
<div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">numpy_array_of_samples</span><span class="p">,</span> <span class="n">numpy_array_of_labels</span><span class="p">,</span>
          <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
<p>Besides the data, you have to specify two key parameters: the <code>batch_size</code> and
the number of epochs (iterations on the data). Here our data will get sliced on batches of 32 samples, and the model will iterate 10 times over the data during training.</p>
<p>Here's what fitting a model looks like with a dataset:</p>
<div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset_of_samples_and_labels</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
<p>Since the data yielded by a dataset is expect to be already batched, you don't need to specify the batch size here.</p>
<p>Let's look at it in practice with a toy example model that learns to classify MNIST digits:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">),</span> <span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>

<span class="c1"># Build a simple model</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">Rescaling</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Flatten</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

<span class="c1"># Compile the model</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;sparse_categorical_crossentropy&#39;</span><span class="p">)</span>

<span class="c1"># Train the model for 1 epoch from Numpy data</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">64</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fit on NumPy data&#39;</span><span class="p">)</span>
<span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Train the model for 1 epoch using a dataset</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">((</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fit on Dataset&#39;</span><span class="p">)</span>
<span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Model: &#34;functional_3&#34;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_2 (InputLayer)         [(None, 28, 28)]          0         
_________________________________________________________________
rescaling_2 (Rescaling)      (None, 28, 28)            0         
_________________________________________________________________
flatten (Flatten)            (None, 784)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 128)               100480    
_________________________________________________________________
dense_2 (Dense)              (None, 128)               16512     
_________________________________________________________________
dense_3 (Dense)              (None, 10)                1290      
=================================================================
Total params: 118,282
Trainable params: 118,282
Non-trainable params: 0
_________________________________________________________________
Fit on NumPy data
938/938 [==============================] - 1s 1ms/step - loss: 0.2707
Fit on Dataset
938/938 [==============================] - 1s 1ms/step - loss: 0.1188
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>fit()</code> call returns a "history" object which records what happened over the course of training. The <code>history.history</code> dict contains per-epoch timeseries of metrics values (here we have only one metric, the loss, and one epoch, so we only get a single scalar):</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{&#39;loss&#39;: [0.1188293844461441]}
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For a detailed overview of how to use <code>fit()</code>, see the
<a href="/guides/training_with_built_in_methods/">guide to training &amp; evaluation with the built-in Keras methods</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Keeping-track-of-performance-metrics">Keeping track of performance metrics<a class="anchor-link" href="#Keeping-track-of-performance-metrics"> </a></h3><p>As you're training a model, you want to keep of track of metrics such as classification accuracy, precision, recall, AUC, etc. Besides, you want to monitor these metrics not only on the training data, but also on a validation set.</p>
<p><strong>Monitoring metrics</strong></p>
<p>You can pass a list of metric objects to <code>compile()</code>, like this:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;sparse_categorical_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">SparseCategoricalAccuracy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;acc&#39;</span><span class="p">)])</span>
<span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>938/938 [==============================] - 1s 1ms/step - loss: 0.0825 - acc: 0.9747
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Passing validation data to <code>fit()</code></strong></p>
<p>You can pass validation data to <code>fit()</code> to monitor your validation loss &amp; validation metrics. Validation metrics get reported at the end of each epoch.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">val_dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">((</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
<span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="n">val_dataset</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>938/938 [==============================] - 1s 1ms/step - loss: 0.0572 - acc: 0.9829 - val_loss: 0.0935 - val_acc: 0.9718
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Using-callbacks-for-checkpointing-(and-more)">Using callbacks for checkpointing (and more)<a class="anchor-link" href="#Using-callbacks-for-checkpointing-(and-more)"> </a></h3><p>If training goes on for more than a few minutes, it's important to save your model at regular intervals during training. You can then use your saved models
to restart training in case your training process crashes (this is important for multi-worker distributed training, since with many workers at least one of them is bound to fail at some point).</p>
<p>An important feature of Keras is <strong>callbacks</strong>, configured in <code>fit()</code>. Callbacks are objects that get called by the model at different point during training, in particular:</p>
<ul>
<li>At the beginning and end of each batch</li>
<li>At the beginning and end of each epoch</li>
</ul>
<p>Callbacks are a way to make model trainable entirely scriptable.</p>
<p>You can use callbacks to periodically save your model. Here's a simple example: a <code>ModelCheckpoint</code> callback
configured to save the model at the end of every epoch. The filename will include the current epoch.</p>
<div class="highlight"><pre><span></span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">ModelCheckpoint</span><span class="p">(</span>
        <span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;path/to/my/model_</span><span class="si">{epoch}</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">save_freq</span><span class="o">=</span><span class="s1">&#39;epoch&#39;</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can also use callbacks to do things like periodically changing the learning of your optimizer, streaming metrics to a Slack bot, sending yourself an email notification when training is complete, etc.</p>
<p>For detailed overview of what callbacks are available and how to write your own, see the <a href="/api/callbacks/">callbacks API documentation</a> and the <a href="/guides/writing_your_own_callbacks/">guide to writing custom callbacks</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Monitoring-training-progress-with-TensorBoard">Monitoring training progress with TensorBoard<a class="anchor-link" href="#Monitoring-training-progress-with-TensorBoard"> </a></h3><p>Staring at the Keras progress bar isn't the most ergonomic way to monitor how your loss and metrics are evolving over time. There's a better solution:
<a href="https://www.tensorflow.org/tensorboard">TensorBoard</a>,
a web application that can display real-time graphs of your metrics (and more).</p>
<p>To use TensorBoard with <code>fit()</code>, simply pass a <code>keras.callbacks.TensorBoard</code> callback specifying the directory where to store TensorBoard logs:</p>
<div class="highlight"><pre><span></span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span><span class="n">log_dir</span><span class="o">=</span><span class="s1">&#39;./logs&#39;</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">)</span>
</pre></div>
<p>You can then launch a TensorBoard instance that you can open in your browser to monitor the logs getting written to this location:</p>

<pre><code>tensorboard --logdir=./logs</code></pre>
<p>What's more, you can launch an in-line TensorBoard tab when training models in Jupyter / Colab notebooks:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> tensorboard

<span class="c1"># Create some TensorBoard logs</span>
<span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span><span class="n">log_dir</span><span class="o">=</span><span class="s1">&#39;./logs&#39;</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">)</span>

<span class="c1"># Launch in-line TensorBoard</span>
<span class="o">%</span><span class="k">tensorboard</span> --logdir logs
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Epoch 1/5
  1/938 [..............................] - ETA: 0s - loss: 0.0207 - acc: 1.0000WARNING:tensorflow:From /Users/jovan.sardinha/Github_personal/jovsatools/venv-jovsatools/lib/python3.6/site-packages/tensorflow/python/ops/summary_ops_v2.py:1277: stop (from tensorflow.python.eager.profiler) is deprecated and will be removed after 2020-07-01.
Instructions for updating:
use `tf.profiler.experimental.stop` instead.
WARNING:tensorflow:Callbacks method `on_train_batch_end` is slow compared to the batch time (batch time: 0.0016s vs `on_train_batch_end` time: 0.0126s). Check your callbacks.
938/938 [==============================] - 1s 1ms/step - loss: 0.0423 - acc: 0.9873
Epoch 2/5
938/938 [==============================] - 1s 1ms/step - loss: 0.0321 - acc: 0.9906
Epoch 3/5
938/938 [==============================] - 1s 1ms/step - loss: 0.0262 - acc: 0.9917
Epoch 4/5
938/938 [==============================] - 1s 1ms/step - loss: 0.0249 - acc: 0.9919
Epoch 5/5
938/938 [==============================] - 1s 1ms/step - loss: 0.0182 - acc: 0.9941
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea ">

      <iframe id="tensorboard-frame-89a1a5c9bd5e1b6a" width="100%" height="800" frameborder="0">
      </iframe>
      <script>
        (function() {
          const frame = document.getElementById("tensorboard-frame-89a1a5c9bd5e1b6a");
          const url = new URL("/", window.location);
          const port = 6006;
          if (port) {
            url.port = port;
          }
          frame.src = url;
        })();
      </script>
    
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="After-fit():-evaluating-test-performance-&amp;-generating-predictions-on-new-data">After <code>fit()</code>: evaluating test performance &amp; generating predictions on new data<a class="anchor-link" href="#After-fit():-evaluating-test-performance-&amp;-generating-predictions-on-new-data"> </a></h3><p>Once you have a train model, you can evaluate its loss and metrics on new data via <code>evaluate()</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">loss</span><span class="p">,</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">)</span>  <span class="c1"># returns loss and metrics</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loss: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">loss</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;acc: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">acc</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>157/157 [==============================] - 0s 1ms/step - loss: 0.1056 - acc: 0.9749
loss: 0.11
acc: 0.97
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can also generate NumPy arrays of predictions (the activations of the output layer(s) in the model) via <code>predict()</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">predictions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(10000, 10)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Using-fit()-with-a-custom-training-step">Using <code>fit()</code> with a custom training step<a class="anchor-link" href="#Using-fit()-with-a-custom-training-step"> </a></h2><p>By default, <code>fit()</code> is configured for <strong>supervised learning</strong>. If you need a different kind of training loop (for instance, a GAN training loop), you
can provide your own implementation of the <code>Model.train_step()</code> method. This is the method that is repeatedly called during <code>fit()</code>.</p>
<p>Metrics, callbacks, etc. will work as usual.</p>
<p>Here's a simple example that reimplements what <code>fit()</code> normally does:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomModel</span><span class="p">(</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1"># Unpack the data. Its structure depends on your model and</span>
    <span class="c1"># on what you pass to `fit()`.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
      <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Forward pass</span>
      <span class="c1"># Compute the loss value</span>
      <span class="c1"># (the loss function is configured in `compile()`)</span>
      <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled_loss</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span>
                                <span class="n">regularization_losses</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">)</span>
    <span class="c1"># Compute gradients</span>
    <span class="n">trainable_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_variables</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">trainable_vars</span><span class="p">)</span>
    <span class="c1"># Update weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">trainable_vars</span><span class="p">))</span>
    <span class="c1"># Update metrics (includes the metric that tracks the loss)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">compiled_metrics</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="c1"># Return a dict mapping metric names to current value</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">}</span>

<span class="c1"># Construct and compile an instance of CustomModel</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,))</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">CustomModel</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>

<span class="c1"># Just use `fit` as usual</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=...</span><span class="p">)</span>
</pre></div>
<p>For a detailed overview of how you customize the built-in training &amp; evaluation loops, see the guide:
<a href="/guides/customizing_what_happens_in_fit/">"Customizing what happens in <code>fit()</code>"</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Debugging-your-model-with-eager-execution">Debugging your model with eager execution<a class="anchor-link" href="#Debugging-your-model-with-eager-execution"> </a></h2><p>If you write custom training steps or custom layers, you will need to debug them. The begugging experience is an integral part of a framework: with Keras, the debugging workflow is designed with the user in mind.</p>
<p>By default, your Keras models are compiled to highly-optimized computation graphs that deliver fast execution times. That means that the Python code you write (e.g. in a custom <code>train_step</code>) is not the code you are actually excecuting. This introduces a layer of indirection that can make debugging hard.</p>
<p>Debugging is best done step by step. You want to be able to sprinkle your code with <code>print()</code>  statement to see what your data looks like after every operation, you want to be able to use <code>pdb</code>. You can achieve this by <strong>running your model eagerly</strong>. With eager execution, the Python code you write is the code that gets executed.</p>
<p>Simply pass <code>run_eagerly=True</code> to <code>compile()</code>:</p>
<div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="n">run_eagerly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Of course, the downside is that it makes your model significantly slower. Make sure to switch it back off to get the benefits of compiled computation graphs once you are done debugging!</p>
<p>In general, you will use <code>run_eagerly=True</code> every time you need to debug what's happening inside your <code>fit()</code> call.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Speeding-up-training-with-multiple-GPUs">Speeding up training with multiple GPUs<a class="anchor-link" href="#Speeding-up-training-with-multiple-GPUs"> </a></h2><p>Keras has built-in industry-strength support for multi-GPU training and distributed multi-worker training, via the <code>tf.distribute</code> API.</p>
<p>If you have multiple GPUs on your machine, you can train your model on all of them by:</p>
<ul>
<li>Creating a <code>tf.distribute.MirroredStrategy</code> object</li>
<li>Building &amp; compiling your model inside the strategy's scope</li>
<li>Calling <code>fit()</code> and <code>evaluate()</code> on a dataset as usual</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># Create a MirroredStrategy.</span>
<span class="n">strategy</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">distribute</span><span class="o">.</span><span class="n">MirroredStrategy</span><span class="p">()</span>

<span class="c1"># Open a strategy scope.</span>
<span class="k">with</span> <span class="n">strategy</span><span class="o">.</span><span class="n">scope</span><span class="p">():</span>
  <span class="c1"># Everything that creates variables should be under the strategy scope.</span>
  <span class="c1"># In general this is only model construction &amp; `compile()`.</span>
  <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c1"># Train the model on all available devices.</span>
<span class="n">train_dataset</span><span class="p">,</span> <span class="n">val_dataset</span><span class="p">,</span> <span class="n">test_dataset</span> <span class="o">=</span> <span class="n">get_dataset</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="n">val_dataset</span><span class="p">)</span>

<span class="c1"># Test the model on all available devices.</span>
<span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">)</span>
</pre></div>
<p>For a detailed introduction to multi-GPU &amp; distributed training, see <a href="/guides/distributed_training/">this guide</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Doing-preprocessing-synchronously-on-device-vs.-asynchronously-on-host-CPU">Doing preprocessing synchronously on-device vs. asynchronously on host CPU<a class="anchor-link" href="#Doing-preprocessing-synchronously-on-device-vs.-asynchronously-on-host-CPU"> </a></h2><p>You've learned about preprocessing, and you've seen example where we put image preprocessing layers (<code>CenterCrop</code> and <code>Rescaling</code>) directly inside our model.</p>
<p>Having preprocessing happen as part of the model during training 
is great if you want to do on-device preprocessing, for instance, GPU-accelerated feature normalization or image augmentation. But there are kinds of preprocessing that are not suited to this setup: in particular, text preprocessing with the <code>TextVectorization</code> layer. Due to its sequential nature and due to the fact that it can only run on CPU, it's often a good idea to do <strong>asynchronous preprocessing</strong>.</p>
<p>With asynchronous preprocessing, your preprocessing operations will run on CPU, and the preprocessed samples will be buffered into a queue while your GPU is busy with previous batch of data. The next batch of preprocessed samples will then be fetched from the queue to the GPU memory right before the GPU becomes available again (prefetching). This ensures that preprocessing will not be blocking and that your GPU can run at full utilization.</p>
<p>To do asynchronous preprocessing, simply use <code>dataset.map</code> to inject a preprocessing operation into your data pipeline:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s2">&quot;This is the 1st sample.&quot;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s2">&quot;And here&#39;s the 2nd sample.&quot;</span><span class="p">]])</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

<span class="c1"># Prepare a TextVectorization layer.</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TextVectorization</span><span class="p">(</span><span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

<span class="c1"># Asynchronous preprocessing: the text vectorization is part of the tf.data pipeline.</span>
<span class="c1"># First, create a dataset</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Apply text vectorization to the samples</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">vectorizer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">))</span>
<span class="c1"># Prefetch with a buffer size of 2 batches</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Our model should expect sequences of integers as inputs</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="mi">32</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="n">run_eagerly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1/1 [==============================] - 0s 644us/step - loss: 0.5180
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;tensorflow.python.keras.callbacks.History at 0x14dca1588&gt;</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Compare this to doing text vectorization as part of the model:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Our model should expect strings as inputs</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="mi">32</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="n">run_eagerly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1/1 [==============================] - 0s 811us/step - loss: 0.4894
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;tensorflow.python.keras.callbacks.History at 0x14dce8278&gt;</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When training text models on CPU, you will generally not see any performance difference between the two setups. When training on GPU, however, doing asynchronous buffered preprocessing on the host CPU while the GPU is running the model itself can result in a significant speedup.</p>
<p>After training, if you to export an end-to-end model that includes the preprocessing layer(s), this is easy to do, since <code>TextVectorization</code> is a layer:</p>
<div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">trained_model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">end_to_end_model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Finding-the-best-model-configuration-with-hyperparameter-tuning">Finding the best model configuration with hyperparameter tuning<a class="anchor-link" href="#Finding-the-best-model-configuration-with-hyperparameter-tuning"> </a></h2><p>Once you have a working model, you're going to want to optimize its configuration -- architecture choices, layer sizes, etc. Human intuition can only go so far, so you'll want to leverage a systematic approach: hyperparameter search.</p>
<p>You can use
<a href="https://keras-team.github.io/keras-tuner/documentation/tuners/">Keras Tuner</a> to find the best hyperparameter for your Keras models. It's as easy as calling <code>fit()</code>.</p>
<p>Here how it works.</p>
<p>First, place your model definition in a function, that takes a single <code>hp</code> argument. Inside this function, replace any value you want to tune with a call to hyperparameter sampling methods, e.g. <code>hp.Int()</code> or <code>hp.Choice()</code>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_model</span><span class="p">(</span><span class="n">hp</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">784</span><span class="p">,))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span>
        <span class="n">units</span><span class="o">=</span><span class="n">hp</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">32</span><span class="p">),</span>
        <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span>
            <span class="n">hp</span><span class="o">.</span><span class="n">Choice</span><span class="p">(</span><span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span>
                      <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">])),</span>
        <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;sparse_categorical_crossentropy&#39;</span><span class="p">,</span>
        <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>
<p>The function should return a compiled model.</p>
<p>Next, instantiate a tuner object specifying your optimiation objective and other search parameters:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">kerastuner</span>

<span class="n">tuner</span> <span class="o">=</span> <span class="n">kerastuner</span><span class="o">.</span><span class="n">tuners</span><span class="o">.</span><span class="n">Hyperband</span><span class="p">(</span>
  <span class="n">build_model</span><span class="p">,</span>
  <span class="n">objective</span><span class="o">=</span><span class="s1">&#39;val_loss&#39;</span><span class="p">,</span>
  <span class="n">max_epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
  <span class="n">max_trials</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
  <span class="n">executions_per_trial</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">directory</span><span class="o">=</span><span class="s1">&#39;my_dir&#39;</span><span class="p">)</span>
</pre></div>
<p>Finally, start the search with the <code>search()</code> method, which takes the same arguments as <code>Model.fit()</code>:</p>
<div class="highlight"><pre><span></span><span class="n">tuner</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="n">val_dataset</span><span class="p">)</span>
</pre></div>
<p>When search is over, you can retrieve the best model(s):</p>
<div class="highlight"><pre><span></span><span class="n">models</span> <span class="o">=</span> <span class="n">tuner</span><span class="o">.</span><span class="n">get_best_models</span><span class="p">(</span><span class="n">num_models</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>Or print a summary of the results:</p>
<div class="highlight"><pre><span></span><span class="n">tuner</span><span class="o">.</span><span class="n">results_summary</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="End-to-end-examples">End-to-end examples<a class="anchor-link" href="#End-to-end-examples"> </a></h2><p>To familiarize yourself with the concepts in this introduction, see the following end-to-end examples:</p>
<ul>
<li><a href="/examples/nlp/text_classification_from_scratch/">Text classification</a></li>
<li><a href="/examples/vision/image_classification_from_scratch/">Image classification</a></li>
<li><a href="/examples/structured_data/imbalanced_classification/">Credit card fraud detection</a></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">References<a class="anchor-link" href="#References"> </a></h2><ul>
<li>Learn more about the
<a href="/guides/functional_api/">Functional API</a>.</li>
<li>Learn more about the
<a href="/guides/training_with_built_in_methods/">features of <code>fit()</code> and <code>evaluate()</code></a>.</li>
<li>Learn more about
<a href="/guides/writing_your_own_callbacks/">callbacks</a>.</li>
<li>Learn more about
<a href="/guides/customizing_what_happens_in_fit/">creating your own custom training steps</a>.</li>
<li>Learn more about
<a href="/guides/distributed_training/">multi-GPU and distributed training</a>.</li>
<li>Learn how to do <a href="/guides/transfer_learning/">transfer learning</a>.</li>
</ul>

</div>
</div>
</div>
</div>
 

